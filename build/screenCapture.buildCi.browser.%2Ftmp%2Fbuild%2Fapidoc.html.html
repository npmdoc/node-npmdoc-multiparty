<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/pillarjs/multiparty#readme">multiparty (v4.1.3)</a>
</h1>
<h4>multipart/form-data parser which supports streaming</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty">module multiparty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form">
            function <span class="apidocSignatureSpan">multiparty.</span>Form
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">multiparty.</span>Form.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form">module multiparty.Form</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.Form">
            function <span class="apidocSignatureSpan">multiparty.</span>Form
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.super_">
            function <span class="apidocSignatureSpan">multiparty.Form.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form.prototype">module multiparty.Form.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype._write">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>_write
            <span class="apidocSignatureSpan">(buffer, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderEnd">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderField">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderField
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderValue">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderValue
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeadersEnd">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeadersEnd
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartBegin">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartBegin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartData">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartData
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartEnd">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.parse">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>parse
            <span class="apidocSignatureSpan">(req, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty" id="apidoc.module.multiparty">module multiparty</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form" id="apidoc.element.multiparty.Form">
        function <span class="apidocSignatureSpan">multiparty.</span>Form
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Form(options) {
  var self = this;
  stream.Writable.call(self);

  options = options || {};

  self.error = null;

  self.autoFields = !!options.autoFields;
  self.autoFiles = !!options.autoFiles;

  self.maxFields = options.maxFields || 1000;
  self.maxFieldsSize = options.maxFieldsSize || 2 * 1024 * 1024;
  self.maxFilesSize = options.maxFilesSize || Infinity;
  self.uploadDir = options.uploadDir || os.tmpdir();
  self.encoding = options.encoding || 'utf8';

  self.bytesReceived = 0;
  self.bytesExpected = null;

  self.openedFiles = [];
  self.totalFieldSize = 0;
  self.totalFieldCount = 0;
  self.totalFileSize = 0;
  self.flushing = 0;

  self.backpressure = false;
  self.writeCbs = [];

  self.emitQueue = [];

  self.on('newListener', function(eventName) {
    if (eventName === 'file') {
      self.autoFiles = true;
    } else if (eventName === 'field') {
      self.autoFields = true;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var multiparty = require('multiparty');
var http = require('http');
var util = require('util');

http.createServer(function(req, res) {
  if (req.url === '/upload' &amp;&amp; req.method === 'POST') {
// parse a file upload
var form = new multiparty.<span class="apidocCodeKeywordSpan">Form</span>();

form.parse(req, function(err, fields, files) {
  res.writeHead(200, {'content-type': 'text/plain'});
  res.write('received upload:\n\n');
  res.end(util.inspect({fields: fields, files: files}));
});
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form" id="apidoc.module.multiparty.Form">module multiparty.Form</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.Form" id="apidoc.element.multiparty.Form.Form">
        function <span class="apidocSignatureSpan">multiparty.</span>Form
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Form(options) {
  var self = this;
  stream.Writable.call(self);

  options = options || {};

  self.error = null;

  self.autoFields = !!options.autoFields;
  self.autoFiles = !!options.autoFiles;

  self.maxFields = options.maxFields || 1000;
  self.maxFieldsSize = options.maxFieldsSize || 2 * 1024 * 1024;
  self.maxFilesSize = options.maxFilesSize || Infinity;
  self.uploadDir = options.uploadDir || os.tmpdir();
  self.encoding = options.encoding || 'utf8';

  self.bytesReceived = 0;
  self.bytesExpected = null;

  self.openedFiles = [];
  self.totalFieldSize = 0;
  self.totalFieldCount = 0;
  self.totalFileSize = 0;
  self.flushing = 0;

  self.backpressure = false;
  self.writeCbs = [];

  self.emitQueue = [];

  self.on('newListener', function(eventName) {
    if (eventName === 'file') {
      self.autoFiles = true;
    } else if (eventName === 'field') {
      self.autoFields = true;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var multiparty = require('multiparty');
var http = require('http');
var util = require('util');

http.createServer(function(req, res) {
  if (req.url === '/upload' &amp;&amp; req.method === 'POST') {
// parse a file upload
var form = new multiparty.<span class="apidocCodeKeywordSpan">Form</span>();

form.parse(req, function(err, fields, files) {
  res.writeHead(200, {'content-type': 'text/plain'});
  res.write('received upload:\n\n');
  res.end(util.inspect({fields: fields, files: files}));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.super_" id="apidoc.element.multiparty.Form.super_">
        function <span class="apidocSignatureSpan">multiparty.Form.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!(realHasInstance.call(Writable, this)) &amp;&amp;
      !(this instanceof Stream.Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;
  }

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form.prototype" id="apidoc.module.multiparty.Form.prototype">module multiparty.Form.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype._write" id="apidoc.element.multiparty.Form.prototype._write">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>_write
        <span class="apidocSignatureSpan">(buffer, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (buffer, encoding, cb) {
  if (this.error) return;

  var self = this;
  var i = 0;
  var len = buffer.length;
  var prevIndex = self.index;
  var index = self.index;
  var state = self.state;
  var lookbehind = self.lookbehind;
  var boundary = self.boundary;
  var boundaryChars = self.boundaryChars;
  var boundaryLength = self.boundary.length;
  var boundaryEnd = boundaryLength - 1;
  var bufferLength = buffer.length;
  var c;
  var cl;

  for (i = 0; i &lt; len; i++) {
    c = buffer[i];
    switch (state) {
      case START:
        index = 0;
        state = START_BOUNDARY;
<span class="apidocCodeCommentSpan">        /* falls through */
</span>      case START_BOUNDARY:
        if (index === boundaryLength - 2 &amp;&amp; c === HYPHEN) {
          index = 1;
          state = CLOSE_BOUNDARY;
          break;
        } else if (index === boundaryLength - 2) {
          if (c !== CR) return self.handleError(createError(400, 'Expected CR Received ' + c));
          index++;
          break;
        } else if (index === boundaryLength - 1) {
          if (c !== LF) return self.handleError(createError(400, 'Expected LF Received ' + c));
          index = 0;
          self.onParsePartBegin();
          state = HEADER_FIELD_START;
          break;
        }

        if (c !== boundary[index+2]) index = -2;
        if (c === boundary[index+2]) index++;
        break;
      case HEADER_FIELD_START:
        state = HEADER_FIELD;
        self.headerFieldMark = i;
        index = 0;
        /* falls through */
      case HEADER_FIELD:
        if (c === CR) {
          self.headerFieldMark = null;
          state = HEADERS_ALMOST_DONE;
          break;
        }

        index++;
        if (c === HYPHEN) break;

        if (c === COLON) {
          if (index === 1) {
            // empty header field
            self.handleError(createError(400, 'Empty header field'));
            return;
          }
          self.onParseHeaderField(buffer.slice(self.headerFieldMark, i));
          self.headerFieldMark = null;
          state = HEADER_VALUE_START;
          break;
        }

        cl = lower(c);
        if (cl &lt; A || cl &gt; Z) {
          self.handleError(createError(400, 'Expected alphabetic character, received ' + c));
          return;
        }
        break;
      case HEADER_VALUE_START:
        if (c === SPACE) break;

        self.headerValueMark = i;
        state = HEADER_VALUE;
        /* falls through */
      case HEADER_VALUE:
        if (c === CR) {
          self.onParseHeaderValue(buffer.slice(self.headerValueMark, i));
          self.headerValueMark = null;
          self.onParseHeaderEnd();
          state = HEADER_VALUE_ALMOST_DONE;
        }
        break;
      case HEADER_VALUE_ALMOST_DONE:
        if (c !== LF) return self.handleError(createError(400, 'Expected LF Received ' + c));
        state = HEADER_FIELD_START;
        break;
      case HEADERS_ALMOST_DONE:
        if (c !== LF) return self.handleError(createError(400, 'Expected LF Received ' + c));
        var err = self.onParseHeadersEnd(i + 1);
        if (err) return self.handleError(err);
        state = PART_DATA_START;
        break;
      case PART_DATA_START:
        state = PART_DATA;
        self.partDataMark = i;
        /* falls through */
      case PART_DATA:
        prevIndex = index;

        if (index === 0) {
          // boyer-moore derrived algorithm to safely skip non-boundary data
          i += boundaryEnd;
          while (i &lt; bufferLength &amp;&amp; !(buffer[i] in boundaryChars)) {
            i += boundaryLength;
          }
          i -= boundaryEnd;
          c = buffer[i];
        }

        if (index &lt; boundaryLength) {
          if (boundary[index] === c) {
            if (index === 0) {
              self.onParsePartData(buffer.slice(self.partDataMark, i));
              self.partDataMark = null;
            }
            index++;
          } else {
            index = 0;
          }
        } else if (index === boundaryLength) {
          index++;
          if (c === CR) {
            // CR = part boundary
            self.partBoundaryFlag = true;
          } else i ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderEnd" id="apidoc.element.multiparty.Form.prototype.onParseHeaderEnd">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeaderEnd = function () {
  this.headerField = this.headerField.toLowerCase();
  this.partHeaders[this.headerField] = this.headerValue;

  var m;
  if (this.headerField === 'content-disposition') {
    if (m = this.headerValue.match(/\bname="([^"]+)"/i)) {
      this.partName = m[1];
    }
    this.partFilename = parseFilename(this.headerValue);
  } else if (this.headerField === 'content-transfer-encoding') {
    this.partTransferEncoding = this.headerValue.toLowerCase();
  }

  this.headerFieldDecoder = new StringDecoder(this.encoding);
  this.headerField = '';
  this.headerValueDecoder = new StringDecoder(this.encoding);
  this.headerValue = '';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.headerValueMark = i;
  state = HEADER_VALUE;
  /* falls through */
case HEADER_VALUE:
  if (c === CR) {
    self.onParseHeaderValue(buffer.slice(self.headerValueMark, i));
    self.headerValueMark = null;
    self.<span class="apidocCodeKeywordSpan">onParseHeaderEnd</span>();
    state = HEADER_VALUE_ALMOST_DONE;
  }
  break;
case HEADER_VALUE_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, 'Expected LF Received ' + c));
  state = HEADER_FIELD_START;
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderField" id="apidoc.element.multiparty.Form.prototype.onParseHeaderField">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderField
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeaderField = function (b) {
  this.headerField += this.headerFieldDecoder.write(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (c === COLON) {
  if (index === 1) {
    // empty header field
    self.handleError(createError(400, 'Empty header field'));
    return;
  }
  self.<span class="apidocCodeKeywordSpan">onParseHeaderField</span>(buffer.slice(self.headerFieldMark, i));
  self.headerFieldMark = null;
  state = HEADER_VALUE_START;
  break;
}

cl = lower(c);
if (cl &lt; A || cl &gt; Z) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderValue" id="apidoc.element.multiparty.Form.prototype.onParseHeaderValue">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderValue
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeaderValue = function (b) {
  this.headerValue += this.headerValueDecoder.write(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (c === SPACE) break;

  self.headerValueMark = i;
  state = HEADER_VALUE;
  /* falls through */
case HEADER_VALUE:
  if (c === CR) {
    self.<span class="apidocCodeKeywordSpan">onParseHeaderValue</span>(buffer.slice(self.headerValueMark, i));
    self.headerValueMark = null;
    self.onParseHeaderEnd();
    state = HEADER_VALUE_ALMOST_DONE;
  }
  break;
case HEADER_VALUE_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, 'Expected LF Received ' + c));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeadersEnd" id="apidoc.element.multiparty.Form.prototype.onParseHeadersEnd">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeadersEnd
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeadersEnd = function (offset) {
  var self = this;
  switch(self.partTransferEncoding){
    case 'binary':
    case '7bit':
    case '8bit':
    self.partTransferEncoding = 'binary';
    break;

    case 'base64': break;
    default:
    return createError(400, 'unknown transfer-encoding: ' + self.partTransferEncoding);
  }

  self.totalFieldCount += 1;
  if (self.totalFieldCount &gt; self.maxFields) {
    return createError(413, 'maxFields ' + self.maxFields + ' exceeded.');
  }

  self.destStream = new stream.PassThrough();
  self.destStream.on('drain', function() {
    flushWriteCbs(self);
  });
  self.destStream.headers = self.partHeaders;
  self.destStream.name = self.partName;
  self.destStream.filename = self.partFilename;
  self.destStream.byteOffset = self.bytesReceived + offset;
  var partContentLength = self.destStream.headers['content-length'];
  self.destStream.byteCount = partContentLength ? parseInt(partContentLength, 10) :
    self.bytesExpected ? (self.bytesExpected - self.destStream.byteOffset -
      self.boundary.length - LAST_BOUNDARY_SUFFIX_LEN) :
    undefined;

  if (self.destStream.filename == null &amp;&amp; self.autoFields) {
    handleField(self, self.destStream);
  } else if (self.destStream.filename != null &amp;&amp; self.autoFiles) {
    handleFile(self, self.destStream);
  } else {
    handlePart(self, self.destStream);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case HEADER_VALUE_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, 'Expected LF Received ' + c));
  state = HEADER_FIELD_START;
  break;
case HEADERS_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, 'Expected LF Received ' + c));
  var err = self.<span class="apidocCodeKeywordSpan">onParseHeadersEnd</span>(i + 1);
  if (err) return self.handleError(err);
  state = PART_DATA_START;
  break;
case PART_DATA_START:
  state = PART_DATA;
  self.partDataMark = i;
  /* falls through */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartBegin" id="apidoc.element.multiparty.Form.prototype.onParsePartBegin">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartBegin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParsePartBegin = function () {
  clearPartVars(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (index === boundaryLength - 2) {
  if (c !== CR) return self.handleError(createError(400, 'Expected CR Received ' + c));
  index++;
  break;
} else if (index === boundaryLength - 1) {
  if (c !== LF) return self.handleError(createError(400, 'Expected LF Received ' + c));
  index = 0;
  self.<span class="apidocCodeKeywordSpan">onParsePartBegin</span>();
  state = HEADER_FIELD_START;
  break;
}

if (c !== boundary[index+2]) index = -2;
if (c === boundary[index+2]) index++;
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartData" id="apidoc.element.multiparty.Form.prototype.onParsePartData">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartData
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParsePartData = function (b) {
  if (this.partTransferEncoding === 'base64') {
    this.backpressure = ! this.destStream.write(b.toString('ascii'), 'base64');
  } else {
    this.backpressure = ! this.destStream.write(b);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i -= boundaryEnd;
  c = buffer[i];
}

if (index &lt; boundaryLength) {
  if (boundary[index] === c) {
    if (index === 0) {
      self.<span class="apidocCodeKeywordSpan">onParsePartData</span>(buffer.slice(self.partDataMark, i));
      self.partDataMark = null;
    }
    index++;
  } else {
    index = 0;
  }
} else if (index === boundaryLength) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartEnd" id="apidoc.element.multiparty.Form.prototype.onParsePartEnd">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParsePartEnd = function () {
  if (this.destStream) {
    flushWriteCbs(this);
    var s = this.destStream;
    process.nextTick(function() {
      s.end();
    });
  }
  clearPartVars(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    index = 0;
  }
} else if (index - 1 === boundaryLength)  {
  if (self.partBoundaryFlag) {
    index = 0;
    if (c === LF) {
      self.partBoundaryFlag = false;
      self.<span class="apidocCodeKeywordSpan">onParsePartEnd</span>();
      self.onParsePartBegin();
      state = HEADER_FIELD_START;
      break;
    }
  } else {
    index = 0;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.parse" id="apidoc.element.multiparty.Form.prototype.parse">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>parse
        <span class="apidocSignatureSpan">(req, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (req, cb) {
  var called = false;
  var self = this;
  var waitend = true;

  if (cb) {
    // if the user supplies a callback, this implies autoFields and autoFiles
    self.autoFields = true;
    self.autoFiles = true;

    // wait for request to end before calling cb
    var end = function (done) {
      if (called) return;

      called = true;

      // wait for req events to fire
      process.nextTick(function() {
        if (waitend &amp;&amp; req.readable) {
          // dump rest of request
          req.resume();
          req.once('end', done);
          return;
        }

        done();
      });
    };

    var fields = {};
    var files = {};
    self.on('error', function(err) {
      end(function() {
        cb(err);
      });
    });
    self.on('field', function(name, value) {
      var fieldsArray = fields[name] || (fields[name] = []);
      fieldsArray.push(value);
    });
    self.on('file', function(name, file) {
      var filesArray = files[name] || (files[name] = []);
      filesArray.push(file);
    });
    self.on('close', function() {
      end(function() {
        cb(null, fields, files);
      });
    });
  }

  self.handleError = handleError;
  self.bytesExpected = getBytesExpected(req.headers);

  req.on('end', onReqEnd);
  req.on('error', function(err) {
    waitend = false;
    handleError(err);
  });
  req.on('aborted', onReqAborted);

  var state = req._readableState;
  if (req._decoder || (state &amp;&amp; (state.encoding || state.decoder))) {
    // this is a binary protocol
    // if an encoding is set, input is likely corrupted
    validationError(new Error('request encoding must not be set'));
    return;
  }

  var contentType = req.headers['content-type'];
  if (!contentType) {
    validationError(createError(415, 'missing content-type header'));
    return;
  }

  var m = CONTENT_TYPE_RE.exec(contentType);
  if (!m) {
    validationError(createError(415, 'unsupported content-type'));
    return;
  }

  var boundary;
  CONTENT_TYPE_PARAM_RE.lastIndex = m.index + m[0].length - 1;
  while ((m = CONTENT_TYPE_PARAM_RE.exec(contentType))) {
    if (m[1].toLowerCase() !== 'boundary') continue;
    boundary = m[2] || m[3];
    break;
  }

  if (!boundary) {
    validationError(createError(400, 'content-type missing boundary'));
    return;
  }

  setUpParser(self, boundary);
  req.pipe(self);

  function onReqAborted() {
    waitend = false;
    self.emit('aborted');
    handleError(new Error("Request aborted"));
  }

  function onReqEnd() {
    waitend = false;
  }

  function handleError(err) {
    var first = !self.error;
    if (first) {
      self.error = err;
      req.removeListener('aborted', onReqAborted);
      req.removeListener('end', onReqEnd);
      if (self.destStream) {
        errorEventQueue(self, self.destStream, err);
      }
    }

    cleanupOpenFiles(self);

    if (first) {
      self.emit('error', err);
    }
  }

  function validationError(err) {
    // handle error on next tick for event listeners to attach
    process.nextTick(handleError.bind(null, err))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var util = require('util');

http.createServer(function(req, res) {
if (req.url === '/upload' &amp;&amp; req.method === 'POST') {
  // parse a file upload
  var form = new multiparty.Form();

  form.<span class="apidocCodeKeywordSpan">parse</span>(req, function(err, fields, files) {
    res.writeHead(200, {'content-type': 'text/plain'});
    res.write('received upload:\n\n');
    res.end(util.inspect({fields: fields, files: files}));
  });

  return;
}
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>