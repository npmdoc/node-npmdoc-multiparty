<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/pillarjs/multiparty#readme"

    >multiparty (v4.1.3)</a>
</h1>
<h4>multipart/form-data parser which supports streaming</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty">module multiparty</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form">
            function <span class="apidocSignatureSpan">multiparty.</span>Form
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype._write">
            function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype._write
            <span class="apidocSignatureSpan">(buffer, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderEnd">
            function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParseHeaderEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderField">
            function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParseHeaderField
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderValue">
            function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParseHeaderValue
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeadersEnd">
            function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParseHeadersEnd
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartBegin">
            function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParsePartBegin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartData">
            function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParsePartData
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartEnd">
            function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParsePartEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.parse">
            function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.parse
            <span class="apidocSignatureSpan">(req, cb)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">multiparty.</span>Form.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form">module multiparty.Form</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.Form">
            function <span class="apidocSignatureSpan">multiparty.</span>Form
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.super_">
            function <span class="apidocSignatureSpan">multiparty.Form.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form.prototype">module multiparty.Form.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype._write">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>_write
            <span class="apidocSignatureSpan">(buffer, encoding, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderEnd">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderField">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderField
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderValue">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderValue
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeadersEnd">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeadersEnd
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartBegin">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartBegin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartData">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartData
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartEnd">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.parse">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>parse
            <span class="apidocSignatureSpan">(req, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form.prototype._write">module multiparty.Form.prototype._write</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype._write._write">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>_write
            <span class="apidocSignatureSpan">(buffer, encoding, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form.prototype.onParseHeaderEnd">module multiparty.Form.prototype.onParseHeaderEnd</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderEnd.onParseHeaderEnd">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form.prototype.onParseHeaderField">module multiparty.Form.prototype.onParseHeaderField</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderField.onParseHeaderField">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderField
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form.prototype.onParseHeaderValue">module multiparty.Form.prototype.onParseHeaderValue</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeaderValue.onParseHeaderValue">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderValue
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form.prototype.onParseHeadersEnd">module multiparty.Form.prototype.onParseHeadersEnd</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParseHeadersEnd.onParseHeadersEnd">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeadersEnd
            <span class="apidocSignatureSpan">(offset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form.prototype.onParsePartBegin">module multiparty.Form.prototype.onParsePartBegin</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartBegin.onParsePartBegin">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartBegin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form.prototype.onParsePartData">module multiparty.Form.prototype.onParsePartData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartData.onParsePartData">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartData
            <span class="apidocSignatureSpan">(b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form.prototype.onParsePartEnd">module multiparty.Form.prototype.onParsePartEnd</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.onParsePartEnd.onParsePartEnd">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartEnd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.multiparty.Form.prototype.parse">module multiparty.Form.prototype.parse</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.multiparty.Form.prototype.parse.parse">
            function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>parse
            <span class="apidocSignatureSpan">(req, cb)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty" id="apidoc.module.multiparty">module multiparty</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form" id="apidoc.element.multiparty.Form">
        function <span class="apidocSignatureSpan">multiparty.</span>Form
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Form(options) {
  var self = this;
  stream.Writable.call(self);

  options = options || {};

  self.error = null;

  self.autoFields = !!options.autoFields;
  self.autoFiles = !!options.autoFiles;

  self.maxFields = options.maxFields || 1000;
  self.maxFieldsSize = options.maxFieldsSize || 2 * 1024 * 1024;
  self.maxFilesSize = options.maxFilesSize || Infinity;
  self.uploadDir = options.uploadDir || os.tmpdir();
  self.encoding = options.encoding || &#x27;utf8&#x27;;

  self.bytesReceived = 0;
  self.bytesExpected = null;

  self.openedFiles = [];
  self.totalFieldSize = 0;
  self.totalFieldCount = 0;
  self.totalFileSize = 0;
  self.flushing = 0;

  self.backpressure = false;
  self.writeCbs = [];

  self.emitQueue = [];

  self.on(&#x27;newListener&#x27;, function(eventName) {
    if (eventName === &#x27;file&#x27;) {
      self.autoFiles = true;
    } else if (eventName === &#x27;field&#x27;) {
      self.autoFields = true;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var multiparty = require(&#x27;multiparty&#x27;);
var http = require(&#x27;http&#x27;);
var util = require(&#x27;util&#x27;);

http.createServer(function(req, res) {
  if (req.url === &#x27;/upload&#x27; &#x26;&#x26; req.method === &#x27;POST&#x27;) {
// parse a file upload
var form = new multiparty.<span class="apidocCodeKeywordSpan">Form</span>();

form.parse(req, function(err, fields, files) {
  res.writeHead(200, {&#x27;content-type&#x27;: &#x27;text/plain&#x27;});
  res.write(&#x27;received upload:\n\n&#x27;);
  res.end(util.inspect({fields: fields, files: files}));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype._write" id="apidoc.element.multiparty.Form.prototype._write">
        function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype._write
        <span class="apidocSignatureSpan">(buffer, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Form.prototype._write = function (buffer, encoding, cb) {
  if (this.error) return;

  var self = this;
  var i = 0;
  var len = buffer.length;
  var prevIndex = self.index;
  var index = self.index;
  var state = self.state;
  var lookbehind = self.lookbehind;
  var boundary = self.boundary;
  var boundaryChars = self.boundaryChars;
  var boundaryLength = self.boundary.length;
  var boundaryEnd = boundaryLength - 1;
  var bufferLength = buffer.length;
  var c;
  var cl;

  for (i = 0; i &#x3c; len; i++) {
    c = buffer[i];
    switch (state) {
      case START:
        index = 0;
        state = START_BOUNDARY;
<span class="apidocCodeCommentSpan">        /* falls through */
</span>      case START_BOUNDARY:
        if (index === boundaryLength - 2 &#x26;&#x26; c === HYPHEN) {
          index = 1;
          state = CLOSE_BOUNDARY;
          break;
        } else if (index === boundaryLength - 2) {
          if (c !== CR) return self.handleError(createError(400, &#x27;Expected CR Received &#x27; + c));
          index++;
          break;
        } else if (index === boundaryLength - 1) {
          if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
          index = 0;
          self.onParsePartBegin();
          state = HEADER_FIELD_START;
          break;
        }

        if (c !== boundary[index+2]) index = -2;
        if (c === boundary[index+2]) index++;
        break;
      case HEADER_FIELD_START:
        state = HEADER_FIELD;
        self.headerFieldMark = i;
        index = 0;
        /* falls through */
      case HEADER_FIELD:
        if (c === CR) {
          self.headerFieldMark = null;
          state = HEADERS_ALMOST_DONE;
          break;
        }

        index++;
        if (c === HYPHEN) break;

        if (c === COLON) {
          if (index === 1) {
            // empty header field
            self.handleError(createError(400, &#x27;Empty header field&#x27;));
            return;
          }
          self.onParseHeaderField(buffer.slice(self.headerFieldMark, i));
          self.headerFieldMark = null;
          state = HEADER_VALUE_START;
          break;
        }

        cl = lower(c);
        if (cl &#x3c; A || cl &#x3e; Z) {
          self.handleError(createError(400, &#x27;Expected alphabetic character, received &#x27; + c));
          return;
        }
        break;
      case HEADER_VALUE_START:
        if (c === SPACE) break;

        self.headerValueMark = i;
        state = HEADER_VALUE;
        /* falls through */
      case HEADER_VALUE:
        if (c === CR) {
          self.onParseHeaderValue(buffer.slice(self.headerValueMark, i));
          self.headerValueMark = null;
          self.onParseHeaderEnd();
          state = HEADER_VALUE_ALMOST_DONE;
        }
        break;
      case HEADER_VALUE_ALMOST_DONE:
        if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
        state = HEADER_FIELD_START;
        break;
      case HEADERS_ALMOST_DONE:
        if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
        var err = self.onParseHeadersEnd(i + 1);
        if (err) return self.handleError(err);
        state = PART_DATA_START;
        break;
      case PART_DATA_START:
        state = PART_DATA;
        self.partDataMark = i;
        /* falls through */
      case PART_DATA:
        prevIndex = index;

        if (index === 0) {
          // boyer-moore derrived algorithm to safely skip non-boundary data
          i += boundaryEnd;
          while (i &#x3c; bufferLength &#x26;&#x26; !(buffer[i] in boundaryChars)) {
            i += boundaryLength;
          }
          i -= boundaryEnd;
          c = buffer[i];
        }

        if (index &#x3c; boundaryLength) {
          if (boundary[index] === c) {
            if (index === 0) {
              self.onParsePartData(buffer.slice(self.partDataMark, i));
              self.partDataMark = null;
            }
            index++;
          } else {
            index = 0;
          }
        } else if (index === boundaryLength) {
          index++;
          if (c === CR) {
            // CR = part boundary
            self.partBoundaryFlag = true;
          } else i ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderEnd" id="apidoc.element.multiparty.Form.prototype.onParseHeaderEnd">
        function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParseHeaderEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Form.prototype.onParseHeaderEnd = function () {
  this.headerField = this.headerField.toLowerCase();
  this.partHeaders[this.headerField] = this.headerValue;

  var m;
  if (this.headerField === &#x27;content-disposition&#x27;) {
    if (m = this.headerValue.match(/\bname=&#x22;([^&#x22;]+)&#x22;/i)) {
      this.partName = m[1];
    }
    this.partFilename = parseFilename(this.headerValue);
  } else if (this.headerField === &#x27;content-transfer-encoding&#x27;) {
    this.partTransferEncoding = this.headerValue.toLowerCase();
  }

  this.headerFieldDecoder = new StringDecoder(this.encoding);
  this.headerField = &#x27;&#x27;;
  this.headerValueDecoder = new StringDecoder(this.encoding);
  this.headerValue = &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderField" id="apidoc.element.multiparty.Form.prototype.onParseHeaderField">
        function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParseHeaderField
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Form.prototype.onParseHeaderField = function (b) {
  this.headerField += this.headerFieldDecoder.write(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderValue" id="apidoc.element.multiparty.Form.prototype.onParseHeaderValue">
        function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParseHeaderValue
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Form.prototype.onParseHeaderValue = function (b) {
  this.headerValue += this.headerValueDecoder.write(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeadersEnd" id="apidoc.element.multiparty.Form.prototype.onParseHeadersEnd">
        function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParseHeadersEnd
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Form.prototype.onParseHeadersEnd = function (offset) {
  var self = this;
  switch(self.partTransferEncoding){
    case &#x27;binary&#x27;:
    case &#x27;7bit&#x27;:
    case &#x27;8bit&#x27;:
    self.partTransferEncoding = &#x27;binary&#x27;;
    break;

    case &#x27;base64&#x27;: break;
    default:
    return createError(400, &#x27;unknown transfer-encoding: &#x27; + self.partTransferEncoding);
  }

  self.totalFieldCount += 1;
  if (self.totalFieldCount &#x3e; self.maxFields) {
    return createError(413, &#x27;maxFields &#x27; + self.maxFields + &#x27; exceeded.&#x27;);
  }

  self.destStream = new stream.PassThrough();
  self.destStream.on(&#x27;drain&#x27;, function() {
    flushWriteCbs(self);
  });
  self.destStream.headers = self.partHeaders;
  self.destStream.name = self.partName;
  self.destStream.filename = self.partFilename;
  self.destStream.byteOffset = self.bytesReceived + offset;
  var partContentLength = self.destStream.headers[&#x27;content-length&#x27;];
  self.destStream.byteCount = partContentLength ? parseInt(partContentLength, 10) :
    self.bytesExpected ? (self.bytesExpected - self.destStream.byteOffset -
      self.boundary.length - LAST_BOUNDARY_SUFFIX_LEN) :
    undefined;

  if (self.destStream.filename == null &#x26;&#x26; self.autoFields) {
    handleField(self, self.destStream);
  } else if (self.destStream.filename != null &#x26;&#x26; self.autoFiles) {
    handleFile(self, self.destStream);
  } else {
    handlePart(self, self.destStream);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartBegin" id="apidoc.element.multiparty.Form.prototype.onParsePartBegin">
        function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParsePartBegin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Form.prototype.onParsePartBegin = function () {
  clearPartVars(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartData" id="apidoc.element.multiparty.Form.prototype.onParsePartData">
        function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParsePartData
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Form.prototype.onParsePartData = function (b) {
  if (this.partTransferEncoding === &#x27;base64&#x27;) {
    this.backpressure = ! this.destStream.write(b.toString(&#x27;ascii&#x27;), &#x27;base64&#x27;);
  } else {
    this.backpressure = ! this.destStream.write(b);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartEnd" id="apidoc.element.multiparty.Form.prototype.onParsePartEnd">
        function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.onParsePartEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Form.prototype.onParsePartEnd = function () {
  if (this.destStream) {
    flushWriteCbs(this);
    var s = this.destStream;
    process.nextTick(function() {
      s.end();
    });
  }
  clearPartVars(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.parse" id="apidoc.element.multiparty.Form.prototype.parse">
        function <span class="apidocSignatureSpan">multiparty.</span>Form.prototype.parse
        <span class="apidocSignatureSpan">(req, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Form.prototype.parse = function (req, cb) {
  var called = false;
  var self = this;
  var waitend = true;

  if (cb) {
    // if the user supplies a callback, this implies autoFields and autoFiles
    self.autoFields = true;
    self.autoFiles = true;

    // wait for request to end before calling cb
    var end = function (done) {
      if (called) return;

      called = true;

      // wait for req events to fire
      process.nextTick(function() {
        if (waitend &#x26;&#x26; req.readable) {
          // dump rest of request
          req.resume();
          req.once(&#x27;end&#x27;, done);
          return;
        }

        done();
      });
    };

    var fields = {};
    var files = {};
    self.on(&#x27;error&#x27;, function(err) {
      end(function() {
        cb(err);
      });
    });
    self.on(&#x27;field&#x27;, function(name, value) {
      var fieldsArray = fields[name] || (fields[name] = []);
      fieldsArray.push(value);
    });
    self.on(&#x27;file&#x27;, function(name, file) {
      var filesArray = files[name] || (files[name] = []);
      filesArray.push(file);
    });
    self.on(&#x27;close&#x27;, function() {
      end(function() {
        cb(null, fields, files);
      });
    });
  }

  self.handleError = handleError;
  self.bytesExpected = getBytesExpected(req.headers);

  req.on(&#x27;end&#x27;, onReqEnd);
  req.on(&#x27;error&#x27;, function(err) {
    waitend = false;
    handleError(err);
  });
  req.on(&#x27;aborted&#x27;, onReqAborted);

  var state = req._readableState;
  if (req._decoder || (state &#x26;&#x26; (state.encoding || state.decoder))) {
    // this is a binary protocol
    // if an encoding is set, input is likely corrupted
    validationError(new Error(&#x27;request encoding must not be set&#x27;));
    return;
  }

  var contentType = req.headers[&#x27;content-type&#x27;];
  if (!contentType) {
    validationError(createError(415, &#x27;missing content-type header&#x27;));
    return;
  }

  var m = CONTENT_TYPE_RE.exec(contentType);
  if (!m) {
    validationError(createError(415, &#x27;unsupported content-type&#x27;));
    return;
  }

  var boundary;
  CONTENT_TYPE_PARAM_RE.lastIndex = m.index + m[0].length - 1;
  while ((m = CONTENT_TYPE_PARAM_RE.exec(contentType))) {
    if (m[1].toLowerCase() !== &#x27;boundary&#x27;) continue;
    boundary = m[2] || m[3];
    break;
  }

  if (!boundary) {
    validationError(createError(400, &#x27;content-type missing boundary&#x27;));
    return;
  }

  setUpParser(self, boundary);
  req.pipe(self);

  function onReqAborted() {
    waitend = false;
    self.emit(&#x27;aborted&#x27;);
    handleError(new Error(&#x22;Request aborted&#x22;));
  }

  function onReqEnd() {
    waitend = false;
  }

  function handleError(err) {
    var first = !self.error;
    if (first) {
      self.error = err;
      req.removeListener(&#x27;aborted&#x27;, onReqAborted);
      req.removeListener(&#x27;end&#x27;, onReqEnd);
      if (self.destStream) {
        errorEventQueue(self, self.destStream, err);
      }
    }

    cleanupOpenFiles(self);

    if (first) {
      self.emit(&#x27;error&#x27;, err);
    }
  }

  function validationError(err) {
    // handle error on next tick for event listeners to attach
    process.nextTick(handleError.bind(null, err))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form" id="apidoc.module.multiparty.Form">module multiparty.Form</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.Form" id="apidoc.element.multiparty.Form.Form">
        function <span class="apidocSignatureSpan">multiparty.</span>Form
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Form(options) {
  var self = this;
  stream.Writable.call(self);

  options = options || {};

  self.error = null;

  self.autoFields = !!options.autoFields;
  self.autoFiles = !!options.autoFiles;

  self.maxFields = options.maxFields || 1000;
  self.maxFieldsSize = options.maxFieldsSize || 2 * 1024 * 1024;
  self.maxFilesSize = options.maxFilesSize || Infinity;
  self.uploadDir = options.uploadDir || os.tmpdir();
  self.encoding = options.encoding || &#x27;utf8&#x27;;

  self.bytesReceived = 0;
  self.bytesExpected = null;

  self.openedFiles = [];
  self.totalFieldSize = 0;
  self.totalFieldCount = 0;
  self.totalFileSize = 0;
  self.flushing = 0;

  self.backpressure = false;
  self.writeCbs = [];

  self.emitQueue = [];

  self.on(&#x27;newListener&#x27;, function(eventName) {
    if (eventName === &#x27;file&#x27;) {
      self.autoFiles = true;
    } else if (eventName === &#x27;field&#x27;) {
      self.autoFields = true;
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var multiparty = require(&#x27;multiparty&#x27;);
var http = require(&#x27;http&#x27;);
var util = require(&#x27;util&#x27;);

http.createServer(function(req, res) {
  if (req.url === &#x27;/upload&#x27; &#x26;&#x26; req.method === &#x27;POST&#x27;) {
// parse a file upload
var form = new multiparty.<span class="apidocCodeKeywordSpan">Form</span>();

form.parse(req, function(err, fields, files) {
  res.writeHead(200, {&#x27;content-type&#x27;: &#x27;text/plain&#x27;});
  res.write(&#x27;received upload:\n\n&#x27;);
  res.end(util.inspect({fields: fields, files: files}));
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.super_" id="apidoc.element.multiparty.Form.super_">
        function <span class="apidocSignatureSpan">multiparty.Form.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writable(options) {
  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!(realHasInstance.call(Writable, this)) &#x26;&#x26;
      !(this instanceof Stream.Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === &#x27;function&#x27;)
      this._write = options.write;

    if (typeof options.writev === &#x27;function&#x27;)
      this._writev = options.writev;
  }

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form.prototype" id="apidoc.module.multiparty.Form.prototype">module multiparty.Form.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype._write" id="apidoc.element.multiparty.Form.prototype._write">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>_write
        <span class="apidocSignatureSpan">(buffer, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (buffer, encoding, cb) {
  if (this.error) return;

  var self = this;
  var i = 0;
  var len = buffer.length;
  var prevIndex = self.index;
  var index = self.index;
  var state = self.state;
  var lookbehind = self.lookbehind;
  var boundary = self.boundary;
  var boundaryChars = self.boundaryChars;
  var boundaryLength = self.boundary.length;
  var boundaryEnd = boundaryLength - 1;
  var bufferLength = buffer.length;
  var c;
  var cl;

  for (i = 0; i &#x3c; len; i++) {
    c = buffer[i];
    switch (state) {
      case START:
        index = 0;
        state = START_BOUNDARY;
<span class="apidocCodeCommentSpan">        /* falls through */
</span>      case START_BOUNDARY:
        if (index === boundaryLength - 2 &#x26;&#x26; c === HYPHEN) {
          index = 1;
          state = CLOSE_BOUNDARY;
          break;
        } else if (index === boundaryLength - 2) {
          if (c !== CR) return self.handleError(createError(400, &#x27;Expected CR Received &#x27; + c));
          index++;
          break;
        } else if (index === boundaryLength - 1) {
          if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
          index = 0;
          self.onParsePartBegin();
          state = HEADER_FIELD_START;
          break;
        }

        if (c !== boundary[index+2]) index = -2;
        if (c === boundary[index+2]) index++;
        break;
      case HEADER_FIELD_START:
        state = HEADER_FIELD;
        self.headerFieldMark = i;
        index = 0;
        /* falls through */
      case HEADER_FIELD:
        if (c === CR) {
          self.headerFieldMark = null;
          state = HEADERS_ALMOST_DONE;
          break;
        }

        index++;
        if (c === HYPHEN) break;

        if (c === COLON) {
          if (index === 1) {
            // empty header field
            self.handleError(createError(400, &#x27;Empty header field&#x27;));
            return;
          }
          self.onParseHeaderField(buffer.slice(self.headerFieldMark, i));
          self.headerFieldMark = null;
          state = HEADER_VALUE_START;
          break;
        }

        cl = lower(c);
        if (cl &#x3c; A || cl &#x3e; Z) {
          self.handleError(createError(400, &#x27;Expected alphabetic character, received &#x27; + c));
          return;
        }
        break;
      case HEADER_VALUE_START:
        if (c === SPACE) break;

        self.headerValueMark = i;
        state = HEADER_VALUE;
        /* falls through */
      case HEADER_VALUE:
        if (c === CR) {
          self.onParseHeaderValue(buffer.slice(self.headerValueMark, i));
          self.headerValueMark = null;
          self.onParseHeaderEnd();
          state = HEADER_VALUE_ALMOST_DONE;
        }
        break;
      case HEADER_VALUE_ALMOST_DONE:
        if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
        state = HEADER_FIELD_START;
        break;
      case HEADERS_ALMOST_DONE:
        if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
        var err = self.onParseHeadersEnd(i + 1);
        if (err) return self.handleError(err);
        state = PART_DATA_START;
        break;
      case PART_DATA_START:
        state = PART_DATA;
        self.partDataMark = i;
        /* falls through */
      case PART_DATA:
        prevIndex = index;

        if (index === 0) {
          // boyer-moore derrived algorithm to safely skip non-boundary data
          i += boundaryEnd;
          while (i &#x3c; bufferLength &#x26;&#x26; !(buffer[i] in boundaryChars)) {
            i += boundaryLength;
          }
          i -= boundaryEnd;
          c = buffer[i];
        }

        if (index &#x3c; boundaryLength) {
          if (boundary[index] === c) {
            if (index === 0) {
              self.onParsePartData(buffer.slice(self.partDataMark, i));
              self.partDataMark = null;
            }
            index++;
          } else {
            index = 0;
          }
        } else if (index === boundaryLength) {
          index++;
          if (c === CR) {
            // CR = part boundary
            self.partBoundaryFlag = true;
          } else i ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderEnd" id="apidoc.element.multiparty.Form.prototype.onParseHeaderEnd">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeaderEnd = function () {
  this.headerField = this.headerField.toLowerCase();
  this.partHeaders[this.headerField] = this.headerValue;

  var m;
  if (this.headerField === &#x27;content-disposition&#x27;) {
    if (m = this.headerValue.match(/\bname=&#x22;([^&#x22;]+)&#x22;/i)) {
      this.partName = m[1];
    }
    this.partFilename = parseFilename(this.headerValue);
  } else if (this.headerField === &#x27;content-transfer-encoding&#x27;) {
    this.partTransferEncoding = this.headerValue.toLowerCase();
  }

  this.headerFieldDecoder = new StringDecoder(this.encoding);
  this.headerField = &#x27;&#x27;;
  this.headerValueDecoder = new StringDecoder(this.encoding);
  this.headerValue = &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.headerValueMark = i;
  state = HEADER_VALUE;
  /* falls through */
case HEADER_VALUE:
  if (c === CR) {
    self.onParseHeaderValue(buffer.slice(self.headerValueMark, i));
    self.headerValueMark = null;
    self.<span class="apidocCodeKeywordSpan">onParseHeaderEnd</span>();
    state = HEADER_VALUE_ALMOST_DONE;
  }
  break;
case HEADER_VALUE_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
  state = HEADER_FIELD_START;
  break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderField" id="apidoc.element.multiparty.Form.prototype.onParseHeaderField">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderField
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeaderField = function (b) {
  this.headerField += this.headerFieldDecoder.write(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (c === COLON) {
  if (index === 1) {
    // empty header field
    self.handleError(createError(400, &#x27;Empty header field&#x27;));
    return;
  }
  self.<span class="apidocCodeKeywordSpan">onParseHeaderField</span>(buffer.slice(self.headerFieldMark, i));
  self.headerFieldMark = null;
  state = HEADER_VALUE_START;
  break;
}

cl = lower(c);
if (cl &#x3c; A || cl &#x3e; Z) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderValue" id="apidoc.element.multiparty.Form.prototype.onParseHeaderValue">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderValue
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeaderValue = function (b) {
  this.headerValue += this.headerValueDecoder.write(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (c === SPACE) break;

  self.headerValueMark = i;
  state = HEADER_VALUE;
  /* falls through */
case HEADER_VALUE:
  if (c === CR) {
    self.<span class="apidocCodeKeywordSpan">onParseHeaderValue</span>(buffer.slice(self.headerValueMark, i));
    self.headerValueMark = null;
    self.onParseHeaderEnd();
    state = HEADER_VALUE_ALMOST_DONE;
  }
  break;
case HEADER_VALUE_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeadersEnd" id="apidoc.element.multiparty.Form.prototype.onParseHeadersEnd">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeadersEnd
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeadersEnd = function (offset) {
  var self = this;
  switch(self.partTransferEncoding){
    case &#x27;binary&#x27;:
    case &#x27;7bit&#x27;:
    case &#x27;8bit&#x27;:
    self.partTransferEncoding = &#x27;binary&#x27;;
    break;

    case &#x27;base64&#x27;: break;
    default:
    return createError(400, &#x27;unknown transfer-encoding: &#x27; + self.partTransferEncoding);
  }

  self.totalFieldCount += 1;
  if (self.totalFieldCount &#x3e; self.maxFields) {
    return createError(413, &#x27;maxFields &#x27; + self.maxFields + &#x27; exceeded.&#x27;);
  }

  self.destStream = new stream.PassThrough();
  self.destStream.on(&#x27;drain&#x27;, function() {
    flushWriteCbs(self);
  });
  self.destStream.headers = self.partHeaders;
  self.destStream.name = self.partName;
  self.destStream.filename = self.partFilename;
  self.destStream.byteOffset = self.bytesReceived + offset;
  var partContentLength = self.destStream.headers[&#x27;content-length&#x27;];
  self.destStream.byteCount = partContentLength ? parseInt(partContentLength, 10) :
    self.bytesExpected ? (self.bytesExpected - self.destStream.byteOffset -
      self.boundary.length - LAST_BOUNDARY_SUFFIX_LEN) :
    undefined;

  if (self.destStream.filename == null &#x26;&#x26; self.autoFields) {
    handleField(self, self.destStream);
  } else if (self.destStream.filename != null &#x26;&#x26; self.autoFiles) {
    handleFile(self, self.destStream);
  } else {
    handlePart(self, self.destStream);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case HEADER_VALUE_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
  state = HEADER_FIELD_START;
  break;
case HEADERS_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
  var err = self.<span class="apidocCodeKeywordSpan">onParseHeadersEnd</span>(i + 1);
  if (err) return self.handleError(err);
  state = PART_DATA_START;
  break;
case PART_DATA_START:
  state = PART_DATA;
  self.partDataMark = i;
  /* falls through */
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartBegin" id="apidoc.element.multiparty.Form.prototype.onParsePartBegin">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartBegin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParsePartBegin = function () {
  clearPartVars(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (index === boundaryLength - 2) {
  if (c !== CR) return self.handleError(createError(400, &#x27;Expected CR Received &#x27; + c));
  index++;
  break;
} else if (index === boundaryLength - 1) {
  if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
  index = 0;
  self.<span class="apidocCodeKeywordSpan">onParsePartBegin</span>();
  state = HEADER_FIELD_START;
  break;
}

if (c !== boundary[index+2]) index = -2;
if (c === boundary[index+2]) index++;
break;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartData" id="apidoc.element.multiparty.Form.prototype.onParsePartData">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartData
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParsePartData = function (b) {
  if (this.partTransferEncoding === &#x27;base64&#x27;) {
    this.backpressure = ! this.destStream.write(b.toString(&#x27;ascii&#x27;), &#x27;base64&#x27;);
  } else {
    this.backpressure = ! this.destStream.write(b);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i -= boundaryEnd;
  c = buffer[i];
}

if (index &#x3c; boundaryLength) {
  if (boundary[index] === c) {
    if (index === 0) {
      self.<span class="apidocCodeKeywordSpan">onParsePartData</span>(buffer.slice(self.partDataMark, i));
      self.partDataMark = null;
    }
    index++;
  } else {
    index = 0;
  }
} else if (index === boundaryLength) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartEnd" id="apidoc.element.multiparty.Form.prototype.onParsePartEnd">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParsePartEnd = function () {
  if (this.destStream) {
    flushWriteCbs(this);
    var s = this.destStream;
    process.nextTick(function() {
      s.end();
    });
  }
  clearPartVars(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    index = 0;
  }
} else if (index - 1 === boundaryLength)  {
  if (self.partBoundaryFlag) {
    index = 0;
    if (c === LF) {
      self.partBoundaryFlag = false;
      self.<span class="apidocCodeKeywordSpan">onParsePartEnd</span>();
      self.onParsePartBegin();
      state = HEADER_FIELD_START;
      break;
    }
  } else {
    index = 0;
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.parse" id="apidoc.element.multiparty.Form.prototype.parse">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>parse
        <span class="apidocSignatureSpan">(req, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (req, cb) {
  var called = false;
  var self = this;
  var waitend = true;

  if (cb) {
    // if the user supplies a callback, this implies autoFields and autoFiles
    self.autoFields = true;
    self.autoFiles = true;

    // wait for request to end before calling cb
    var end = function (done) {
      if (called) return;

      called = true;

      // wait for req events to fire
      process.nextTick(function() {
        if (waitend &#x26;&#x26; req.readable) {
          // dump rest of request
          req.resume();
          req.once(&#x27;end&#x27;, done);
          return;
        }

        done();
      });
    };

    var fields = {};
    var files = {};
    self.on(&#x27;error&#x27;, function(err) {
      end(function() {
        cb(err);
      });
    });
    self.on(&#x27;field&#x27;, function(name, value) {
      var fieldsArray = fields[name] || (fields[name] = []);
      fieldsArray.push(value);
    });
    self.on(&#x27;file&#x27;, function(name, file) {
      var filesArray = files[name] || (files[name] = []);
      filesArray.push(file);
    });
    self.on(&#x27;close&#x27;, function() {
      end(function() {
        cb(null, fields, files);
      });
    });
  }

  self.handleError = handleError;
  self.bytesExpected = getBytesExpected(req.headers);

  req.on(&#x27;end&#x27;, onReqEnd);
  req.on(&#x27;error&#x27;, function(err) {
    waitend = false;
    handleError(err);
  });
  req.on(&#x27;aborted&#x27;, onReqAborted);

  var state = req._readableState;
  if (req._decoder || (state &#x26;&#x26; (state.encoding || state.decoder))) {
    // this is a binary protocol
    // if an encoding is set, input is likely corrupted
    validationError(new Error(&#x27;request encoding must not be set&#x27;));
    return;
  }

  var contentType = req.headers[&#x27;content-type&#x27;];
  if (!contentType) {
    validationError(createError(415, &#x27;missing content-type header&#x27;));
    return;
  }

  var m = CONTENT_TYPE_RE.exec(contentType);
  if (!m) {
    validationError(createError(415, &#x27;unsupported content-type&#x27;));
    return;
  }

  var boundary;
  CONTENT_TYPE_PARAM_RE.lastIndex = m.index + m[0].length - 1;
  while ((m = CONTENT_TYPE_PARAM_RE.exec(contentType))) {
    if (m[1].toLowerCase() !== &#x27;boundary&#x27;) continue;
    boundary = m[2] || m[3];
    break;
  }

  if (!boundary) {
    validationError(createError(400, &#x27;content-type missing boundary&#x27;));
    return;
  }

  setUpParser(self, boundary);
  req.pipe(self);

  function onReqAborted() {
    waitend = false;
    self.emit(&#x27;aborted&#x27;);
    handleError(new Error(&#x22;Request aborted&#x22;));
  }

  function onReqEnd() {
    waitend = false;
  }

  function handleError(err) {
    var first = !self.error;
    if (first) {
      self.error = err;
      req.removeListener(&#x27;aborted&#x27;, onReqAborted);
      req.removeListener(&#x27;end&#x27;, onReqEnd);
      if (self.destStream) {
        errorEventQueue(self, self.destStream, err);
      }
    }

    cleanupOpenFiles(self);

    if (first) {
      self.emit(&#x27;error&#x27;, err);
    }
  }

  function validationError(err) {
    // handle error on next tick for event listeners to attach
    process.nextTick(handleError.bind(null, err))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var util = require(&#x27;util&#x27;);

http.createServer(function(req, res) {
if (req.url === &#x27;/upload&#x27; &#x26;&#x26; req.method === &#x27;POST&#x27;) {
  // parse a file upload
  var form = new multiparty.Form();

  form.<span class="apidocCodeKeywordSpan">parse</span>(req, function(err, fields, files) {
    res.writeHead(200, {&#x27;content-type&#x27;: &#x27;text/plain&#x27;});
    res.write(&#x27;received upload:\n\n&#x27;);
    res.end(util.inspect({fields: fields, files: files}));
  });

  return;
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form.prototype._write" id="apidoc.module.multiparty.Form.prototype._write">module multiparty.Form.prototype._write</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype._write._write" id="apidoc.element.multiparty.Form.prototype._write._write">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>_write
        <span class="apidocSignatureSpan">(buffer, encoding, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_write = function (buffer, encoding, cb) {
  if (this.error) return;

  var self = this;
  var i = 0;
  var len = buffer.length;
  var prevIndex = self.index;
  var index = self.index;
  var state = self.state;
  var lookbehind = self.lookbehind;
  var boundary = self.boundary;
  var boundaryChars = self.boundaryChars;
  var boundaryLength = self.boundary.length;
  var boundaryEnd = boundaryLength - 1;
  var bufferLength = buffer.length;
  var c;
  var cl;

  for (i = 0; i &#x3c; len; i++) {
    c = buffer[i];
    switch (state) {
      case START:
        index = 0;
        state = START_BOUNDARY;
<span class="apidocCodeCommentSpan">        /* falls through */
</span>      case START_BOUNDARY:
        if (index === boundaryLength - 2 &#x26;&#x26; c === HYPHEN) {
          index = 1;
          state = CLOSE_BOUNDARY;
          break;
        } else if (index === boundaryLength - 2) {
          if (c !== CR) return self.handleError(createError(400, &#x27;Expected CR Received &#x27; + c));
          index++;
          break;
        } else if (index === boundaryLength - 1) {
          if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
          index = 0;
          self.onParsePartBegin();
          state = HEADER_FIELD_START;
          break;
        }

        if (c !== boundary[index+2]) index = -2;
        if (c === boundary[index+2]) index++;
        break;
      case HEADER_FIELD_START:
        state = HEADER_FIELD;
        self.headerFieldMark = i;
        index = 0;
        /* falls through */
      case HEADER_FIELD:
        if (c === CR) {
          self.headerFieldMark = null;
          state = HEADERS_ALMOST_DONE;
          break;
        }

        index++;
        if (c === HYPHEN) break;

        if (c === COLON) {
          if (index === 1) {
            // empty header field
            self.handleError(createError(400, &#x27;Empty header field&#x27;));
            return;
          }
          self.onParseHeaderField(buffer.slice(self.headerFieldMark, i));
          self.headerFieldMark = null;
          state = HEADER_VALUE_START;
          break;
        }

        cl = lower(c);
        if (cl &#x3c; A || cl &#x3e; Z) {
          self.handleError(createError(400, &#x27;Expected alphabetic character, received &#x27; + c));
          return;
        }
        break;
      case HEADER_VALUE_START:
        if (c === SPACE) break;

        self.headerValueMark = i;
        state = HEADER_VALUE;
        /* falls through */
      case HEADER_VALUE:
        if (c === CR) {
          self.onParseHeaderValue(buffer.slice(self.headerValueMark, i));
          self.headerValueMark = null;
          self.onParseHeaderEnd();
          state = HEADER_VALUE_ALMOST_DONE;
        }
        break;
      case HEADER_VALUE_ALMOST_DONE:
        if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
        state = HEADER_FIELD_START;
        break;
      case HEADERS_ALMOST_DONE:
        if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
        var err = self.onParseHeadersEnd(i + 1);
        if (err) return self.handleError(err);
        state = PART_DATA_START;
        break;
      case PART_DATA_START:
        state = PART_DATA;
        self.partDataMark = i;
        /* falls through */
      case PART_DATA:
        prevIndex = index;

        if (index === 0) {
          // boyer-moore derrived algorithm to safely skip non-boundary data
          i += boundaryEnd;
          while (i &#x3c; bufferLength &#x26;&#x26; !(buffer[i] in boundaryChars)) {
            i += boundaryLength;
          }
          i -= boundaryEnd;
          c = buffer[i];
        }

        if (index &#x3c; boundaryLength) {
          if (boundary[index] === c) {
            if (index === 0) {
              self.onParsePartData(buffer.slice(self.partDataMark, i));
              self.partDataMark = null;
            }
            index++;
          } else {
            index = 0;
          }
        } else if (index === boundaryLength) {
          index++;
          if (c === CR) {
            // CR = part boundary
            self.partBoundaryFlag = true;
          } else i ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form.prototype.onParseHeaderEnd" id="apidoc.module.multiparty.Form.prototype.onParseHeaderEnd">module multiparty.Form.prototype.onParseHeaderEnd</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderEnd.onParseHeaderEnd" id="apidoc.element.multiparty.Form.prototype.onParseHeaderEnd.onParseHeaderEnd">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeaderEnd = function () {
  this.headerField = this.headerField.toLowerCase();
  this.partHeaders[this.headerField] = this.headerValue;

  var m;
  if (this.headerField === &#x27;content-disposition&#x27;) {
    if (m = this.headerValue.match(/\bname=&#x22;([^&#x22;]+)&#x22;/i)) {
      this.partName = m[1];
    }
    this.partFilename = parseFilename(this.headerValue);
  } else if (this.headerField === &#x27;content-transfer-encoding&#x27;) {
    this.partTransferEncoding = this.headerValue.toLowerCase();
  }

  this.headerFieldDecoder = new StringDecoder(this.encoding);
  this.headerField = &#x27;&#x27;;
  this.headerValueDecoder = new StringDecoder(this.encoding);
  this.headerValue = &#x27;&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  self.headerValueMark = i;
  state = HEADER_VALUE;
  /* falls through */
case HEADER_VALUE:
  if (c === CR) {
    self.onParseHeaderValue(buffer.slice(self.headerValueMark, i));
    self.headerValueMark = null;
    self.<span class="apidocCodeKeywordSpan">onParseHeaderEnd</span>();
    state = HEADER_VALUE_ALMOST_DONE;
  }
  break;
case HEADER_VALUE_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
  state = HEADER_FIELD_START;
  break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form.prototype.onParseHeaderField" id="apidoc.module.multiparty.Form.prototype.onParseHeaderField">module multiparty.Form.prototype.onParseHeaderField</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderField.onParseHeaderField" id="apidoc.element.multiparty.Form.prototype.onParseHeaderField.onParseHeaderField">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderField
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeaderField = function (b) {
  this.headerField += this.headerFieldDecoder.write(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (c === COLON) {
  if (index === 1) {
    // empty header field
    self.handleError(createError(400, &#x27;Empty header field&#x27;));
    return;
  }
  self.<span class="apidocCodeKeywordSpan">onParseHeaderField</span>(buffer.slice(self.headerFieldMark, i));
  self.headerFieldMark = null;
  state = HEADER_VALUE_START;
  break;
}

cl = lower(c);
if (cl &#x3c; A || cl &#x3e; Z) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form.prototype.onParseHeaderValue" id="apidoc.module.multiparty.Form.prototype.onParseHeaderValue">module multiparty.Form.prototype.onParseHeaderValue</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeaderValue.onParseHeaderValue" id="apidoc.element.multiparty.Form.prototype.onParseHeaderValue.onParseHeaderValue">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeaderValue
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeaderValue = function (b) {
  this.headerValue += this.headerValueDecoder.write(b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (c === SPACE) break;

  self.headerValueMark = i;
  state = HEADER_VALUE;
  /* falls through */
case HEADER_VALUE:
  if (c === CR) {
    self.<span class="apidocCodeKeywordSpan">onParseHeaderValue</span>(buffer.slice(self.headerValueMark, i));
    self.headerValueMark = null;
    self.onParseHeaderEnd();
    state = HEADER_VALUE_ALMOST_DONE;
  }
  break;
case HEADER_VALUE_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form.prototype.onParseHeadersEnd" id="apidoc.module.multiparty.Form.prototype.onParseHeadersEnd">module multiparty.Form.prototype.onParseHeadersEnd</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParseHeadersEnd.onParseHeadersEnd" id="apidoc.element.multiparty.Form.prototype.onParseHeadersEnd.onParseHeadersEnd">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParseHeadersEnd
        <span class="apidocSignatureSpan">(offset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParseHeadersEnd = function (offset) {
  var self = this;
  switch(self.partTransferEncoding){
    case &#x27;binary&#x27;:
    case &#x27;7bit&#x27;:
    case &#x27;8bit&#x27;:
    self.partTransferEncoding = &#x27;binary&#x27;;
    break;

    case &#x27;base64&#x27;: break;
    default:
    return createError(400, &#x27;unknown transfer-encoding: &#x27; + self.partTransferEncoding);
  }

  self.totalFieldCount += 1;
  if (self.totalFieldCount &#x3e; self.maxFields) {
    return createError(413, &#x27;maxFields &#x27; + self.maxFields + &#x27; exceeded.&#x27;);
  }

  self.destStream = new stream.PassThrough();
  self.destStream.on(&#x27;drain&#x27;, function() {
    flushWriteCbs(self);
  });
  self.destStream.headers = self.partHeaders;
  self.destStream.name = self.partName;
  self.destStream.filename = self.partFilename;
  self.destStream.byteOffset = self.bytesReceived + offset;
  var partContentLength = self.destStream.headers[&#x27;content-length&#x27;];
  self.destStream.byteCount = partContentLength ? parseInt(partContentLength, 10) :
    self.bytesExpected ? (self.bytesExpected - self.destStream.byteOffset -
      self.boundary.length - LAST_BOUNDARY_SUFFIX_LEN) :
    undefined;

  if (self.destStream.filename == null &#x26;&#x26; self.autoFields) {
    handleField(self, self.destStream);
  } else if (self.destStream.filename != null &#x26;&#x26; self.autoFiles) {
    handleFile(self, self.destStream);
  } else {
    handlePart(self, self.destStream);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  break;
case HEADER_VALUE_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
  state = HEADER_FIELD_START;
  break;
case HEADERS_ALMOST_DONE:
  if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
  var err = self.<span class="apidocCodeKeywordSpan">onParseHeadersEnd</span>(i + 1);
  if (err) return self.handleError(err);
  state = PART_DATA_START;
  break;
case PART_DATA_START:
  state = PART_DATA;
  self.partDataMark = i;
  /* falls through */
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form.prototype.onParsePartBegin" id="apidoc.module.multiparty.Form.prototype.onParsePartBegin">module multiparty.Form.prototype.onParsePartBegin</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartBegin.onParsePartBegin" id="apidoc.element.multiparty.Form.prototype.onParsePartBegin.onParsePartBegin">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartBegin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParsePartBegin = function () {
  clearPartVars(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (index === boundaryLength - 2) {
  if (c !== CR) return self.handleError(createError(400, &#x27;Expected CR Received &#x27; + c));
  index++;
  break;
} else if (index === boundaryLength - 1) {
  if (c !== LF) return self.handleError(createError(400, &#x27;Expected LF Received &#x27; + c));
  index = 0;
  self.<span class="apidocCodeKeywordSpan">onParsePartBegin</span>();
  state = HEADER_FIELD_START;
  break;
}

if (c !== boundary[index+2]) index = -2;
if (c === boundary[index+2]) index++;
break;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form.prototype.onParsePartData" id="apidoc.module.multiparty.Form.prototype.onParsePartData">module multiparty.Form.prototype.onParsePartData</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartData.onParsePartData" id="apidoc.element.multiparty.Form.prototype.onParsePartData.onParsePartData">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartData
        <span class="apidocSignatureSpan">(b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParsePartData = function (b) {
  if (this.partTransferEncoding === &#x27;base64&#x27;) {
    this.backpressure = ! this.destStream.write(b.toString(&#x27;ascii&#x27;), &#x27;base64&#x27;);
  } else {
    this.backpressure = ! this.destStream.write(b);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  i -= boundaryEnd;
  c = buffer[i];
}

if (index &#x3c; boundaryLength) {
  if (boundary[index] === c) {
    if (index === 0) {
      self.<span class="apidocCodeKeywordSpan">onParsePartData</span>(buffer.slice(self.partDataMark, i));
      self.partDataMark = null;
    }
    index++;
  } else {
    index = 0;
  }
} else if (index === boundaryLength) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form.prototype.onParsePartEnd" id="apidoc.module.multiparty.Form.prototype.onParsePartEnd">module multiparty.Form.prototype.onParsePartEnd</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.onParsePartEnd.onParsePartEnd" id="apidoc.element.multiparty.Form.prototype.onParsePartEnd.onParsePartEnd">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>onParsePartEnd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onParsePartEnd = function () {
  if (this.destStream) {
    flushWriteCbs(this);
    var s = this.destStream;
    process.nextTick(function() {
      s.end();
    });
  }
  clearPartVars(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    index = 0;
  }
} else if (index - 1 === boundaryLength)  {
  if (self.partBoundaryFlag) {
    index = 0;
    if (c === LF) {
      self.partBoundaryFlag = false;
      self.<span class="apidocCodeKeywordSpan">onParsePartEnd</span>();
      self.onParsePartBegin();
      state = HEADER_FIELD_START;
      break;
    }
  } else {
    index = 0;
  }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.multiparty.Form.prototype.parse" id="apidoc.module.multiparty.Form.prototype.parse">module multiparty.Form.prototype.parse</a></h1>


    <h2>
        <a href="#apidoc.element.multiparty.Form.prototype.parse.parse" id="apidoc.element.multiparty.Form.prototype.parse.parse">
        function <span class="apidocSignatureSpan">multiparty.Form.prototype.</span>parse
        <span class="apidocSignatureSpan">(req, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parse = function (req, cb) {
  var called = false;
  var self = this;
  var waitend = true;

  if (cb) {
    // if the user supplies a callback, this implies autoFields and autoFiles
    self.autoFields = true;
    self.autoFiles = true;

    // wait for request to end before calling cb
    var end = function (done) {
      if (called) return;

      called = true;

      // wait for req events to fire
      process.nextTick(function() {
        if (waitend &#x26;&#x26; req.readable) {
          // dump rest of request
          req.resume();
          req.once(&#x27;end&#x27;, done);
          return;
        }

        done();
      });
    };

    var fields = {};
    var files = {};
    self.on(&#x27;error&#x27;, function(err) {
      end(function() {
        cb(err);
      });
    });
    self.on(&#x27;field&#x27;, function(name, value) {
      var fieldsArray = fields[name] || (fields[name] = []);
      fieldsArray.push(value);
    });
    self.on(&#x27;file&#x27;, function(name, file) {
      var filesArray = files[name] || (files[name] = []);
      filesArray.push(file);
    });
    self.on(&#x27;close&#x27;, function() {
      end(function() {
        cb(null, fields, files);
      });
    });
  }

  self.handleError = handleError;
  self.bytesExpected = getBytesExpected(req.headers);

  req.on(&#x27;end&#x27;, onReqEnd);
  req.on(&#x27;error&#x27;, function(err) {
    waitend = false;
    handleError(err);
  });
  req.on(&#x27;aborted&#x27;, onReqAborted);

  var state = req._readableState;
  if (req._decoder || (state &#x26;&#x26; (state.encoding || state.decoder))) {
    // this is a binary protocol
    // if an encoding is set, input is likely corrupted
    validationError(new Error(&#x27;request encoding must not be set&#x27;));
    return;
  }

  var contentType = req.headers[&#x27;content-type&#x27;];
  if (!contentType) {
    validationError(createError(415, &#x27;missing content-type header&#x27;));
    return;
  }

  var m = CONTENT_TYPE_RE.exec(contentType);
  if (!m) {
    validationError(createError(415, &#x27;unsupported content-type&#x27;));
    return;
  }

  var boundary;
  CONTENT_TYPE_PARAM_RE.lastIndex = m.index + m[0].length - 1;
  while ((m = CONTENT_TYPE_PARAM_RE.exec(contentType))) {
    if (m[1].toLowerCase() !== &#x27;boundary&#x27;) continue;
    boundary = m[2] || m[3];
    break;
  }

  if (!boundary) {
    validationError(createError(400, &#x27;content-type missing boundary&#x27;));
    return;
  }

  setUpParser(self, boundary);
  req.pipe(self);

  function onReqAborted() {
    waitend = false;
    self.emit(&#x27;aborted&#x27;);
    handleError(new Error(&#x22;Request aborted&#x22;));
  }

  function onReqEnd() {
    waitend = false;
  }

  function handleError(err) {
    var first = !self.error;
    if (first) {
      self.error = err;
      req.removeListener(&#x27;aborted&#x27;, onReqAborted);
      req.removeListener(&#x27;end&#x27;, onReqEnd);
      if (self.destStream) {
        errorEventQueue(self, self.destStream, err);
      }
    }

    cleanupOpenFiles(self);

    if (first) {
      self.emit(&#x27;error&#x27;, err);
    }
  }

  function validationError(err) {
    // handle error on next tick for event listeners to attach
    process.nextTick(handleError.bind(null, err))
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var util = require(&#x27;util&#x27;);

http.createServer(function(req, res) {
if (req.url === &#x27;/upload&#x27; &#x26;&#x26; req.method === &#x27;POST&#x27;) {
  // parse a file upload
  var form = new multiparty.Form();

  form.<span class="apidocCodeKeywordSpan">parse</span>(req, function(err, fields, files) {
    res.writeHead(200, {&#x27;content-type&#x27;: &#x27;text/plain&#x27;});
    res.write(&#x27;received upload:\n\n&#x27;);
    res.end(util.inspect({fields: fields, files: files}));
  });

  return;
}
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
